/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.mydsl.generator

import java.util.ArrayList
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.pascal.block
import org.xtext.example.mydsl.pascal.digitSequence
import org.xtext.example.mydsl.pascal.factor
import org.xtext.example.mydsl.pascal.integerNumber
import org.xtext.example.mydsl.pascal.realNumber
import org.xtext.example.mydsl.pascal.scaleFactor
import org.xtext.example.mydsl.pascal.term

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PascalGenerator extends AbstractGenerator {
	
		
	private int currentReg;
	private int currentLine;
	private Map<String, String> mapRegs;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
	}
	
	def compileAttribution(block block) '''	
		«FOR statement:block.compoundStatement.statements.statement»
				«IF statement !== null && statement.unlabelledStatement.simpleStatement !== null && statement.unlabelledStatement.simpleStatement.assignmentStatement !== null && statement.unlabelledStatement.simpleStatement.assignmentStatement.expression !== null»
					«FOR simple_expression: statement.unlabelledStatement.simpleStatement.assignmentStatement.expression.simpleExpression»
						«var List<Integer> listSum = new ArrayList<Integer>()»
						«var List<String> listSign= new ArrayList<String>()»
						«var List<Integer> listMul = new ArrayList<Integer>()»
						«var variableLeftName = statement.assignment_statement.variable.entire_variable.identifier.identifier»
						«IF simple_expression !== null»
							«FOR term:simple_expression.term»													
								«IF simple_expression.addition_operator.size == 0 && term.multiplication_operator.size == 0»
									«IF term !== null»
										«FOR factor: term.factor»
											«getCodeExpression(factor, variableLeftName)»
										«ENDFOR»
									«ENDIF»
								«ENDIF»
								«IF simple_expression.addition_operator.size == 0 && term.multiplication_operator.size > 0»
									«FOR multiplication_operator: term.multiplication_operator»
										«var aux = listSign.add(multiplication_operator)»
									«ENDFOR»
									«IF term !== null»	
										«loadForExpressionAddOrMul(term, variableLeftName, listMul)»
									«ENDIF»
								«ENDIF»
								«IF simple_expression.addition_operator.size > 0 && term.multiplication_operator.size == 0»
									«FOR addition_operator: simple_expression.addition_operator»
										«var aux = listSign.add(addition_operator.sign)»
									«ENDFOR»
									«IF term !== null»	
										«loadForExpressionAddOrMul(term, variableLeftName, listSum)»
									«ENDIF»
								«ENDIF»								
							«ENDFOR»
						«ENDIF»
						«storageMUL(listMul, variableLeftName, listSign)»
						«storageSum(listSum, variableLeftName, listSign)»						
					«ENDFOR»					
				«ENDIF»		
			«ENDFOR»
'''
	
	
	def getNextLine(){
		currentLine +=8;
		return currentLine+": ";
	}
	
	def getNextReg(){
		currentReg++;
		return "R"+currentReg;
	}
	def getCurrentReg(){
		return "R"+currentReg;
	}
	
	
	def storageMUL(List<Integer> listMul, String variableLeftName, List<String> listSign) '''
		«IF listMul.size > 1»
			«FOR i : 1 .. listMul.size-1»
				«IF listSign.get(i-1).equals('*')»
					«getNextLine() + "MUL "+ "R"+listMul.get(0) + ", R"+ listMul.get(0) + ", R" + listMul.get(i)»
				«ENDIF»
				«IF listSign.get(i-1).equals('/') || listSign.get(i-1).equals('div')»
					«getNextLine() + "DIV "+ "R"+listMul.get(0) + ", R"+ listMul.get(0) + ", R" + listMul.get(i)»
				«ENDIF»
			«ENDFOR»
			«getNextLine() + "ST "+ variableLeftName +", R"+ listMul.get(0)»
		«ENDIF»
	'''
		
	def storageSum(List<Integer> listSum, String variableLeftName, List<String> listSign) '''
		«IF listSum.size > 1»
			«FOR i : 1 .. listSum.size-1»
				«IF listSign.get(i-1).equals("+")»
					«getNextLine() + "ADD "+ "R"+listSum.get(0) + ", R"+ listSum.get(0) + ", R" + listSum.get(i)»
				«ENDIF»
				«IF listSign.get(i-1).equals("-")»
					«getNextLine() + "SUB "+ "R"+listSum.get(0) + ", R"+ listSum.get(0) + ", R" + listSum.get(i)»
				«ENDIF»
			«ENDFOR»
			«getNextLine() + "ST "+ variableLeftName +", R"+ listSum.get(0)»
		«ENDIF»
	'''
	
	def loadForExpressionAddOrMul(term term, String variableLeftName, List<Integer> listOperands)'''
		«FOR factor: term.factor»
			«IF factor !== null && factor.variable !== null && factor.variable.entireVariable !== null»
				«var variableRigthName = factor.variable.entireVariable.identifier.identifier»
				«getNextLine() + "LD " + nextReg + ", " + variableRigthName»
				«var aux = listOperands.add(currentReg)»
			«ENDIF»
			« IF factor !== null && factor.identifier !== null»
				«getNextLine() + "LD " + nextReg + ", " + factor.identifier.identifier»
				«var aux = listOperands.add(currentReg)»
			«ENDIF»
			«IF factor !== null && factor.number !== null»	
				«IF factor.number.integerNumber !== null»
					«getNextLine() + "LD " + nextReg + ", #" + getIntegerNumber(factor.number.integerNumber)»
					«var aux = listOperands.add(currentReg)»
				«ELSE»
					«getNextLine() + "LD " + nextReg + ", #" + getRealNumber(factor.number.realNumber)»
					«var aux = listOperands.add(currentReg)»
				«ENDIF»
			«ENDIF»	
			« IF factor !== null && factor.strings !== null»
				«getNextLine() + "LD " + nextReg + ", " +factor.strings»
				«var aux = listOperands.add(currentReg)»
			«ENDIF»		
		«ENDFOR»
	'''
	
	def getCodeExpression(factor factor, String variableLeftName)'''
		«IF factor !== null && factor.variable !== null && factor.variable.entireVariable !== null»
			«var variableRigthName = factor.variable.entireVariable.identifier.identifier»
			«getNextLine() + "ST " + variableLeftName + ", " + variableRigthName»
		«ENDIF»
		« IF factor !== null && factor.identifier !== null»
			«getNextLine() + "ST " + variableLeftName + ", " + factor.identifier.identifier»
		«ENDIF»
		« IF factor !== null && factor.number !== null»
			«IF factor.number.integerNumber !== null»
				«getNextLine() + "ST " + variableLeftName + ", #" + getIntegerNumber(factor.number.integerNumber)»
			«ELSE»
				«getNextLine() + "ST " +  variableLeftName + ", #" + getRealNumber(factor.number.realNumber)»
			«ENDIF»
		«ENDIF»	
		« IF factor !== null && factor.strings !== null»
			«getNextLine() + "ST " + variableLeftName + ", " +factor.strings»
		«ENDIF»
	'''
	
	def getRealNumber(realNumber realNumber) {
		var output  = "";
		output += getDigitSequence(realNumber.digitSequence);
		
		if (realNumber.digitSequence2 !== null) {
			output += "." + getDigitSequence(realNumber.digitSequence2)
		}		
		if (realNumber.scaleFactor !== null) {
			output += getScaleFactor(realNumber.scaleFactor);
		}
		
		return output;
		
	}
	
	def getScaleFactor(scaleFactor factor) {
		var output = "";
		output += "e";
		if (factor.sign !== null) {
			output += factor.sign;
		}
		output += getDigitSequence(factor.digitSequence);
		
	}
	
	def getDigitSequence(digitSequence digitSequence) {
		var output = "";
		if (digitSequence.sign !== null) {
			output += digitSequence.sign;
		}
		output += digitSequence.unsignedDigitSequence;
		
		return output;
	}
	
	def getIntegerNumber(integerNumber integerNumber) {
		return getDigitSequence(integerNumber.digitSequence);
	}
	

}
