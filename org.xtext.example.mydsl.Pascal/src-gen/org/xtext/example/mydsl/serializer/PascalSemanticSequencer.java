/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.pascal.PascalPackage;
import org.xtext.example.mydsl.pascal.StringStart;
import org.xtext.example.mydsl.pascal.actualParameter;
import org.xtext.example.mydsl.pascal.assignmentStatement;
import org.xtext.example.mydsl.pascal.block;
import org.xtext.example.mydsl.pascal.bool;
import org.xtext.example.mydsl.pascal.compoundStatement;
import org.xtext.example.mydsl.pascal.constList;
import org.xtext.example.mydsl.pascal.constant;
import org.xtext.example.mydsl.pascal.constantChr;
import org.xtext.example.mydsl.pascal.constantDefinition;
import org.xtext.example.mydsl.pascal.constantDefinitionPart;
import org.xtext.example.mydsl.pascal.expression;
import org.xtext.example.mydsl.pascal.factor;
import org.xtext.example.mydsl.pascal.fieldList;
import org.xtext.example.mydsl.pascal.formalParameterList;
import org.xtext.example.mydsl.pascal.formalParameterSection;
import org.xtext.example.mydsl.pascal.functionDeclaration;
import org.xtext.example.mydsl.pascal.functionDesignator;
import org.xtext.example.mydsl.pascal.functionType;
import org.xtext.example.mydsl.pascal.gotoStatement;
import org.xtext.example.mydsl.pascal.identifier;
import org.xtext.example.mydsl.pascal.identifierList;
import org.xtext.example.mydsl.pascal.labelDeclarationPart;
import org.xtext.example.mydsl.pascal.labelStart;
import org.xtext.example.mydsl.pascal.parameterGroup;
import org.xtext.example.mydsl.pascal.parameterList;
import org.xtext.example.mydsl.pascal.pointerType;
import org.xtext.example.mydsl.pascal.procedureAndFunctionDeclarationPart;
import org.xtext.example.mydsl.pascal.procedureDeclaration;
import org.xtext.example.mydsl.pascal.procedureOrFunctionDeclaration;
import org.xtext.example.mydsl.pascal.procedureStatement;
import org.xtext.example.mydsl.pascal.procedureType;
import org.xtext.example.mydsl.pascal.programHeading;
import org.xtext.example.mydsl.pascal.programStart;
import org.xtext.example.mydsl.pascal.recordSection;
import org.xtext.example.mydsl.pascal.recordType;
import org.xtext.example.mydsl.pascal.recordVariableList;
import org.xtext.example.mydsl.pascal.repeatStatement;
import org.xtext.example.mydsl.pascal.resultType;
import org.xtext.example.mydsl.pascal.scalarType;
import org.xtext.example.mydsl.pascal.sign;
import org.xtext.example.mydsl.pascal.signedFactor;
import org.xtext.example.mydsl.pascal.simpleExpression;
import org.xtext.example.mydsl.pascal.simpleStatement;
import org.xtext.example.mydsl.pascal.simpleType;
import org.xtext.example.mydsl.pascal.statement;
import org.xtext.example.mydsl.pascal.statements;
import org.xtext.example.mydsl.pascal.stringtype;
import org.xtext.example.mydsl.pascal.structuredStatement;
import org.xtext.example.mydsl.pascal.structuredType;
import org.xtext.example.mydsl.pascal.subrangeType;
import org.xtext.example.mydsl.pascal.tag;
import org.xtext.example.mydsl.pascal.term;
import org.xtext.example.mydsl.pascal.toBegin;
import org.xtext.example.mydsl.pascal.typeDefinition;
import org.xtext.example.mydsl.pascal.typeDefinitionPart;
import org.xtext.example.mydsl.pascal.typeIdentifier;
import org.xtext.example.mydsl.pascal.typeStart;
import org.xtext.example.mydsl.pascal.unlabelledStatement;
import org.xtext.example.mydsl.pascal.unpackedStructuredType;
import org.xtext.example.mydsl.pascal.unsignedConstant;
import org.xtext.example.mydsl.pascal.unsignedInteger;
import org.xtext.example.mydsl.pascal.unsignedNumber;
import org.xtext.example.mydsl.pascal.unsignedReal;
import org.xtext.example.mydsl.pascal.usesUnitsPart;
import org.xtext.example.mydsl.pascal.variable;
import org.xtext.example.mydsl.pascal.variableDeclaration;
import org.xtext.example.mydsl.pascal.variableDeclarationPart;
import org.xtext.example.mydsl.pascal.variant;
import org.xtext.example.mydsl.pascal.variantPart;
import org.xtext.example.mydsl.pascal.withStatement;
import org.xtext.example.mydsl.services.PascalGrammarAccess;

@SuppressWarnings("all")
public class PascalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalPackage.STRING_START:
				sequence_StringStart(context, (StringStart) semanticObject); 
				return; 
			case PascalPackage.ACTUAL_PARAMETER:
				sequence_actualParameter(context, (actualParameter) semanticObject); 
				return; 
			case PascalPackage.ASSIGNMENT_STATEMENT:
				sequence_assignmentStatement(context, (assignmentStatement) semanticObject); 
				return; 
			case PascalPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case PascalPackage.BOOL:
				sequence_bool(context, (bool) semanticObject); 
				return; 
			case PascalPackage.COMPOUND_STATEMENT:
				sequence_compoundStatement(context, (compoundStatement) semanticObject); 
				return; 
			case PascalPackage.CONST_LIST:
				sequence_constList(context, (constList) semanticObject); 
				return; 
			case PascalPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_CHR:
				sequence_constantChr(context, (constantChr) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION:
				sequence_constantDefinition(context, (constantDefinition) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION_PART:
				sequence_constantDefinitionPart(context, (constantDefinitionPart) semanticObject); 
				return; 
			case PascalPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case PascalPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case PascalPackage.FIELD_LIST:
				sequence_fieldList(context, (fieldList) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_LIST:
				sequence_formalParameterList(context, (formalParameterList) semanticObject); 
				return; 
			case PascalPackage.FORMAL_PARAMETER_SECTION:
				sequence_formalParameterSection(context, (formalParameterSection) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_DECLARATION:
				sequence_functionDeclaration(context, (functionDeclaration) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_DESIGNATOR:
				sequence_functionDesignator(context, (functionDesignator) semanticObject); 
				return; 
			case PascalPackage.FUNCTION_TYPE:
				sequence_functionType(context, (functionType) semanticObject); 
				return; 
			case PascalPackage.GOTO_STATEMENT:
				sequence_gotoStatement(context, (gotoStatement) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER:
				sequence_identifier(context, (identifier) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER_LIST:
				sequence_identifierList(context, (identifierList) semanticObject); 
				return; 
			case PascalPackage.LABEL_DECLARATION_PART:
				sequence_labelDeclarationPart(context, (labelDeclarationPart) semanticObject); 
				return; 
			case PascalPackage.LABEL_START:
				sequence_labelStart(context, (labelStart) semanticObject); 
				return; 
			case PascalPackage.PARAMETER_GROUP:
				sequence_parameterGroup(context, (parameterGroup) semanticObject); 
				return; 
			case PascalPackage.PARAMETER_LIST:
				sequence_parameterList(context, (parameterList) semanticObject); 
				return; 
			case PascalPackage.POINTER_TYPE:
				sequence_pointerType(context, (pointerType) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_AND_FUNCTION_DECLARATION_PART:
				sequence_procedureAndFunctionDeclarationPart(context, (procedureAndFunctionDeclarationPart) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_DECLARATION:
				sequence_procedureDeclaration(context, (procedureDeclaration) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_OR_FUNCTION_DECLARATION:
				sequence_procedureOrFunctionDeclaration(context, (procedureOrFunctionDeclaration) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_STATEMENT:
				sequence_procedureStatement(context, (procedureStatement) semanticObject); 
				return; 
			case PascalPackage.PROCEDURE_TYPE:
				sequence_procedureType(context, (procedureType) semanticObject); 
				return; 
			case PascalPackage.PROGRAM_HEADING:
				sequence_programHeading(context, (programHeading) semanticObject); 
				return; 
			case PascalPackage.PROGRAM_START:
				sequence_programStart(context, (programStart) semanticObject); 
				return; 
			case PascalPackage.RECORD_SECTION:
				if (rule == grammarAccess.getFixedPartRule()) {
					sequence_fixedPart_recordSection(context, (recordSection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecordSectionRule()) {
					sequence_recordSection(context, (recordSection) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.RECORD_TYPE:
				sequence_recordType(context, (recordType) semanticObject); 
				return; 
			case PascalPackage.RECORD_VARIABLE_LIST:
				sequence_recordVariableList(context, (recordVariableList) semanticObject); 
				return; 
			case PascalPackage.REPEAT_STATEMENT:
				sequence_repeatStatement(context, (repeatStatement) semanticObject); 
				return; 
			case PascalPackage.RESULT_TYPE:
				sequence_resultType(context, (resultType) semanticObject); 
				return; 
			case PascalPackage.SCALAR_TYPE:
				sequence_scalarType(context, (scalarType) semanticObject); 
				return; 
			case PascalPackage.SIGN:
				sequence_sign(context, (sign) semanticObject); 
				return; 
			case PascalPackage.SIGNED_FACTOR:
				sequence_signedFactor(context, (signedFactor) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_EXPRESSION:
				sequence_simpleExpression(context, (simpleExpression) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_STATEMENT:
				sequence_simpleStatement(context, (simpleStatement) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_TYPE:
				sequence_simpleType(context, (simpleType) semanticObject); 
				return; 
			case PascalPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case PascalPackage.STATEMENTS:
				sequence_statements(context, (statements) semanticObject); 
				return; 
			case PascalPackage.STRINGTYPE:
				sequence_stringtype(context, (stringtype) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_STATEMENT:
				sequence_structuredStatement(context, (structuredStatement) semanticObject); 
				return; 
			case PascalPackage.STRUCTURED_TYPE:
				sequence_structuredType(context, (structuredType) semanticObject); 
				return; 
			case PascalPackage.SUBRANGE_TYPE:
				sequence_subrangeType(context, (subrangeType) semanticObject); 
				return; 
			case PascalPackage.TAG:
				sequence_tag(context, (tag) semanticObject); 
				return; 
			case PascalPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case PascalPackage.TO_BEGIN:
				sequence_toBegin(context, (toBegin) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION:
				sequence_typeDefinition(context, (typeDefinition) semanticObject); 
				return; 
			case PascalPackage.TYPE_DEFINITION_PART:
				sequence_typeDefinitionPart(context, (typeDefinitionPart) semanticObject); 
				return; 
			case PascalPackage.TYPE_IDENTIFIER:
				sequence_typeIdentifier(context, (typeIdentifier) semanticObject); 
				return; 
			case PascalPackage.TYPE_START:
				sequence_typeStart(context, (typeStart) semanticObject); 
				return; 
			case PascalPackage.UNLABELLED_STATEMENT:
				sequence_unlabelledStatement(context, (unlabelledStatement) semanticObject); 
				return; 
			case PascalPackage.UNPACKED_STRUCTURED_TYPE:
				sequence_unpackedStructuredType(context, (unpackedStructuredType) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_CONSTANT:
				sequence_unsignedConstant(context, (unsignedConstant) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_INTEGER:
				sequence_unsignedInteger(context, (unsignedInteger) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_NUMBER:
				sequence_unsignedNumber(context, (unsignedNumber) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_REAL:
				sequence_unsignedReal(context, (unsignedReal) semanticObject); 
				return; 
			case PascalPackage.USES_UNITS_PART:
				sequence_usesUnitsPart(context, (usesUnitsPart) semanticObject); 
				return; 
			case PascalPackage.VARIABLE:
				sequence_variable(context, (variable) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION:
				sequence_variableDeclaration(context, (variableDeclaration) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION_PART:
				sequence_variableDeclarationPart(context, (variableDeclarationPart) semanticObject); 
				return; 
			case PascalPackage.VARIANT:
				sequence_variant(context, (variant) semanticObject); 
				return; 
			case PascalPackage.VARIANT_PART:
				sequence_variantPart(context, (variantPart) semanticObject); 
				return; 
			case PascalPackage.WITH_STATEMENT:
				sequence_withStatement(context, (withStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     StringStart returns StringStart
	 *
	 * Constraint:
	 *     StringStart=STRING
	 */
	protected void sequence_StringStart(ISerializationContext context, StringStart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.STRING_START__STRING_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.STRING_START__STRING_START));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringStartAccess().getStringStartSTRINGTerminalRuleCall_0(), semanticObject.getStringStart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     actualParameter returns actualParameter
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_actualParameter(ISerializationContext context, actualParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ACTUAL_PARAMETER__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ACTUAL_PARAMETER__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActualParameterAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     assignmentStatement returns assignmentStatement
	 *
	 * Constraint:
	 *     (variable=variable expression=expression)
	 */
	protected void sequence_assignmentStatement(ISerializationContext context, assignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             labelDeclarationPart+=labelDeclarationPart | 
	 *             constantDefinitionPart+=constantDefinitionPart | 
	 *             typeDefinitionPart+=typeDefinitionPart | 
	 *             variableDeclarationPart+=variableDeclarationPart | 
	 *             procedureAndFunctionDeclarationPart+=procedureAndFunctionDeclarationPart | 
	 *             usesUnitsPart+=usesUnitsPart | 
	 *             ImplemeTerminal+='implementation'
	 *         )* 
	 *         compoundStatement=compoundStatement
	 *     )
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns bool
	 *     bool returns bool
	 *
	 * Constraint:
	 *     (bool='true' | bool='false')
	 */
	protected void sequence_bool(ISerializationContext context, bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compoundStatement returns compoundStatement
	 *
	 * Constraint:
	 *     statements=statements
	 */
	protected void sequence_compoundStatement(ISerializationContext context, compoundStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__STATEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__STATEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompoundStatementAccess().getStatementsStatementsParserRuleCall_1_0(), semanticObject.getStatements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constList returns constList
	 *
	 * Constraint:
	 *     (constant1=constant (commaTerminal+=',' constant2+=constant)*)
	 */
	protected void sequence_constList(ISerializationContext context, constList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constantChr returns constantChr
	 *
	 * Constraint:
	 *     unsignedInteger=unsignedInteger
	 */
	protected void sequence_constantChr(ISerializationContext context, constantChr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_CHR__UNSIGNED_INTEGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_CHR__UNSIGNED_INTEGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantChrAccess().getUnsignedIntegerUnsignedIntegerParserRuleCall_2_0(), semanticObject.getUnsignedInteger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constantDefinitionPart returns constantDefinitionPart
	 *
	 * Constraint:
	 *     (constantDefinition+=constantDefinition semiTerminal+=';')+
	 */
	protected void sequence_constantDefinitionPart(ISerializationContext context, constantDefinitionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constantDefinition returns constantDefinition
	 *
	 * Constraint:
	 *     (ID=identifier constant=constant)
	 */
	protected void sequence_constantDefinition(ISerializationContext context, constantDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__ID));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.CONSTANT_DEFINITION__CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getIDIdentifierParserRuleCall_0_0(), semanticObject.getID());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getConstantConstantParserRuleCall_2_0(), semanticObject.getConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (
	 *         unsignedNumber=unsignedNumber | 
	 *         (sign1=sign unsignedNumber=unsignedNumber) | 
	 *         identifier1=identifier | 
	 *         (sign2=sign identifier2=identifier) | 
	 *         string=StringStart | 
	 *         constantChr=constantChr
	 *     )
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     simpleExpression=simpleExpression
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.EXPRESSION__SIMPLE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.EXPRESSION__SIMPLE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getSimpleExpressionSimpleExpressionParserRuleCall_0(), semanticObject.getSimpleExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         variable=variable | 
	 *         expression=expression | 
	 *         functionDesignator=functionDesignator | 
	 *         unsignedConstant=unsignedConstant | 
	 *         (not='not' factor=factor) | 
	 *         bool=bool
	 *     )
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldList returns fieldList
	 *
	 * Constraint:
	 *     ((fixedPart=fixedPart (semiTerminal=';' variantPart1=variantPart)?) | variantPart2=variantPart)
	 */
	protected void sequence_fieldList(ISerializationContext context, fieldList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fixedPart returns recordSection
	 *
	 * Constraint:
	 *     (identifierList=identifierList typeStart=typeStart (semiTerminal+=';' recordSection+=recordSection)*)
	 */
	protected void sequence_fixedPart_recordSection(ISerializationContext context, recordSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameterList returns formalParameterList
	 *
	 * Constraint:
	 *     (formalParameterSection1=formalParameterSection (semiterminal+=';' formalParameterSection2+=formalParameterSection)*)
	 */
	protected void sequence_formalParameterList(ISerializationContext context, formalParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameterSection returns formalParameterSection
	 *
	 * Constraint:
	 *     (parameterGroup=parameterGroup | parameterGroup=parameterGroup | parameterGroup=parameterGroup | parameterGroup=parameterGroup)
	 */
	protected void sequence_formalParameterSection(ISerializationContext context, formalParameterSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionDeclaration returns functionDeclaration
	 *
	 * Constraint:
	 *     (identifier=identifier formalParameterList=formalParameterList? resultType=resultType block=block)
	 */
	protected void sequence_functionDeclaration(ISerializationContext context, functionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionDesignator returns functionDesignator
	 *
	 * Constraint:
	 *     (identifier=identifier parameterList=parameterList)
	 */
	protected void sequence_functionDesignator(ISerializationContext context, functionDesignator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__PARAMETER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.FUNCTION_DESIGNATOR__PARAMETER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDesignatorAccess().getIdentifierIdentifierParserRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getFunctionDesignatorAccess().getParameterListParameterListParserRuleCall_2_0(), semanticObject.getParameterList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     functionType returns functionType
	 *
	 * Constraint:
	 *     (formalParameterList=formalParameterList? resultType=resultType)
	 */
	protected void sequence_functionType(ISerializationContext context, functionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     gotoStatement returns gotoStatement
	 *
	 * Constraint:
	 *     labelStart=labelStart
	 */
	protected void sequence_gotoStatement(ISerializationContext context, gotoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.GOTO_STATEMENT__LABEL_START));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoStatementAccess().getLabelStartLabelStartParserRuleCall_1_0(), semanticObject.getLabelStart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifierList returns identifierList
	 *
	 * Constraint:
	 *     (identifier1=identifier (commaTerminal+=',' identifier2+=identifier)*)
	 */
	protected void sequence_identifierList(ISerializationContext context, identifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier returns identifier
	 *
	 * Constraint:
	 *     identifier=IDENT
	 */
	protected void sequence_identifier(ISerializationContext context, identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.IDENTIFIER__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.IDENTIFIER__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierAccess().getIdentifierIDENTTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     labelDeclarationPart returns labelDeclarationPart
	 *
	 * Constraint:
	 *     (labelStart1=labelStart (commaTerminal+=',' labelStart2+=labelStart)*)
	 */
	protected void sequence_labelDeclarationPart(ISerializationContext context, labelDeclarationPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     labelStart returns labelStart
	 *
	 * Constraint:
	 *     unsignedInteger=unsignedInteger
	 */
	protected void sequence_labelStart(ISerializationContext context, labelStart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.LABEL_START__UNSIGNED_INTEGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.LABEL_START__UNSIGNED_INTEGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelStartAccess().getUnsignedIntegerUnsignedIntegerParserRuleCall_0(), semanticObject.getUnsignedInteger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameterGroup returns parameterGroup
	 *
	 * Constraint:
	 *     (identifierList=identifierList typeIdentifier=typeIdentifier)
	 */
	protected void sequence_parameterGroup(ISerializationContext context, parameterGroup semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PARAMETER_GROUP__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterGroupAccess().getIdentifierListIdentifierListParserRuleCall_0_0(), semanticObject.getIdentifierList());
		feeder.accept(grammarAccess.getParameterGroupAccess().getTypeIdentifierTypeIdentifierParserRuleCall_2_0(), semanticObject.getTypeIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameterList returns parameterList
	 *
	 * Constraint:
	 *     (actualParameter1=actualParameter actualParameter2+=actualParameter*)
	 */
	protected void sequence_parameterList(ISerializationContext context, parameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointerType returns pointerType
	 *
	 * Constraint:
	 *     typeIdentifier=typeIdentifier
	 */
	protected void sequence_pointerType(ISerializationContext context, pointerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.POINTER_TYPE__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerTypeAccess().getTypeIdentifierTypeIdentifierParserRuleCall_1_0(), semanticObject.getTypeIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedureAndFunctionDeclarationPart returns procedureAndFunctionDeclarationPart
	 *
	 * Constraint:
	 *     procedureOrFunctionDeclaration=procedureOrFunctionDeclaration
	 */
	protected void sequence_procedureAndFunctionDeclarationPart(ISerializationContext context, procedureAndFunctionDeclarationPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROCEDURE_AND_FUNCTION_DECLARATION_PART__PROCEDURE_OR_FUNCTION_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROCEDURE_AND_FUNCTION_DECLARATION_PART__PROCEDURE_OR_FUNCTION_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureAndFunctionDeclarationPartAccess().getProcedureOrFunctionDeclarationProcedureOrFunctionDeclarationParserRuleCall_0_0(), semanticObject.getProcedureOrFunctionDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     procedureDeclaration returns procedureDeclaration
	 *
	 * Constraint:
	 *     (identifier=identifier formalParameterList=formalParameterList? block=block)
	 */
	protected void sequence_procedureDeclaration(ISerializationContext context, procedureDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureOrFunctionDeclaration returns procedureOrFunctionDeclaration
	 *
	 * Constraint:
	 *     (procedureDeclaration=procedureDeclaration | functionDeclaration=functionDeclaration)
	 */
	protected void sequence_procedureOrFunctionDeclaration(ISerializationContext context, procedureOrFunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureStatement returns procedureStatement
	 *
	 * Constraint:
	 *     (identifier=identifier parameterList=parameterList?)
	 */
	protected void sequence_procedureStatement(ISerializationContext context, procedureStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureType returns procedureType
	 *
	 * Constraint:
	 *     formalParameterList=formalParameterList?
	 */
	protected void sequence_procedureType(ISerializationContext context, procedureType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     programHeading returns programHeading
	 *
	 * Constraint:
	 *     ((identifier1=identifier identifierList+=identifierList?) | identifier2=identifier)
	 */
	protected void sequence_programHeading(ISerializationContext context, programHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     programStart returns programStart
	 *
	 * Constraint:
	 *     (programHeading=programHeading interface='interface'? block=block)
	 */
	protected void sequence_programStart(ISerializationContext context, programStart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recordSection returns recordSection
	 *
	 * Constraint:
	 *     (identifierList=identifierList typeStart=typeStart)
	 */
	protected void sequence_recordSection(ISerializationContext context, recordSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RECORD_SECTION__TYPE_START));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordSectionAccess().getIdentifierListIdentifierListParserRuleCall_0_0(), semanticObject.getIdentifierList());
		feeder.accept(grammarAccess.getRecordSectionAccess().getTypeStartTypeStartParserRuleCall_2_0(), semanticObject.getTypeStart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recordType returns recordType
	 *
	 * Constraint:
	 *     (fieldList=fieldList semiTerminal=';')?
	 */
	protected void sequence_recordType(ISerializationContext context, recordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recordVariableList returns recordVariableList
	 *
	 * Constraint:
	 *     (variable1=variable (commaTerminal+=',' variable2+=variable)*)
	 */
	protected void sequence_recordVariableList(ISerializationContext context, recordVariableList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     repetetiveStatement returns repeatStatement
	 *     repeatStatement returns repeatStatement
	 *
	 * Constraint:
	 *     (statement=statements expression=expression)
	 */
	protected void sequence_repeatStatement(ISerializationContext context, repeatStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.REPEAT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatStatementAccess().getStatementStatementsParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getRepeatStatementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     resultType returns resultType
	 *
	 * Constraint:
	 *     typeIdentifier=typeIdentifier
	 */
	protected void sequence_resultType(ISerializationContext context, resultType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.RESULT_TYPE__TYPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.RESULT_TYPE__TYPE_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResultTypeAccess().getTypeIdentifierTypeIdentifierParserRuleCall_0(), semanticObject.getTypeIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     scalarType returns scalarType
	 *
	 * Constraint:
	 *     identifierList=identifierList
	 */
	protected void sequence_scalarType(ISerializationContext context, scalarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SCALAR_TYPE__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SCALAR_TYPE__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeAccess().getIdentifierListIdentifierListParserRuleCall_1_0(), semanticObject.getIdentifierList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     sign returns sign
	 *
	 * Constraint:
	 *     (sign='+' | sign='-')
	 */
	protected void sequence_sign(ISerializationContext context, sign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     signedFactor returns signedFactor
	 *
	 * Constraint:
	 *     factor=factor
	 */
	protected void sequence_signedFactor(ISerializationContext context, signedFactor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SIGNED_FACTOR__FACTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SIGNED_FACTOR__FACTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignedFactorAccess().getFactorFactorParserRuleCall_1_0(), semanticObject.getFactor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     simpleExpression returns simpleExpression
	 *
	 * Constraint:
	 *     (term=term simpleExpression=simpleExpression?)
	 */
	protected void sequence_simpleExpression(ISerializationContext context, simpleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simpleStatement returns simpleStatement
	 *
	 * Constraint:
	 *     (assignmentStatement=assignmentStatement | procedureStatement=procedureStatement | gotoStatement=gotoStatement)
	 */
	protected void sequence_simpleStatement(ISerializationContext context, simpleStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simpleType returns simpleType
	 *
	 * Constraint:
	 *     (simpleType=scalarType | simpleType=subrangeType | simpleType=typeIdentifier | simpleType=stringtype)
	 */
	protected void sequence_simpleType(ISerializationContext context, simpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     ((labelStart=labelStart unlabelledStatement=unlabelledStatement) | unlabelledStatement=unlabelledStatement)
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statements returns statements
	 *
	 * Constraint:
	 *     (statement1+=statement (semiTerminal1+=';' statement2+=statement)* semiTerminal2=';')
	 */
	protected void sequence_statements(ISerializationContext context, statements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stringtype returns stringtype
	 *
	 * Constraint:
	 *     (stringTerminal=STRING (ID=identifier | unsignedNumber=unsignedNumber))
	 */
	protected void sequence_stringtype(ISerializationContext context, stringtype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structuredStatement returns structuredStatement
	 *
	 * Constraint:
	 *     (compoundStatement=compoundStatement | repetetiveStatement=repetetiveStatement | withStatement=withStatement)
	 */
	protected void sequence_structuredStatement(ISerializationContext context, structuredStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structuredType returns structuredType
	 *
	 * Constraint:
	 *     (unpackedStructuredType1=unpackedStructuredType | unpackedStructuredType2=unpackedStructuredType)
	 */
	protected void sequence_structuredType(ISerializationContext context, structuredType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     subrangeType returns subrangeType
	 *
	 * Constraint:
	 *     (constant1=constant constan2=constant)
	 */
	protected void sequence_subrangeType(ISerializationContext context, subrangeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTANT1));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTAN2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.SUBRANGE_TYPE__CONSTAN2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getConstant1ConstantParserRuleCall_0_0(), semanticObject.getConstant1());
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getConstan2ConstantParserRuleCall_2_0(), semanticObject.getConstan2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tag returns tag
	 *
	 * Constraint:
	 *     ((ID=identifier typeIdentifier1=typeIdentifier) | typeIdentifier2=typeIdentifier)
	 */
	protected void sequence_tag(ISerializationContext context, tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (signedFactor=signedFactor term=term?)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     toBegin returns toBegin
	 *
	 * Constraint:
	 *     elements=programStart
	 */
	protected void sequence_toBegin(ISerializationContext context, toBegin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.TO_BEGIN__ELEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.TO_BEGIN__ELEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToBeginAccess().getElementsProgramStartParserRuleCall_0(), semanticObject.getElements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeDefinitionPart returns typeDefinitionPart
	 *
	 * Constraint:
	 *     (typeDefinition+=typeDefinition semiTerminal+=';')+
	 */
	protected void sequence_typeDefinitionPart(ISerializationContext context, typeDefinitionPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeDefinition returns typeDefinition
	 *
	 * Constraint:
	 *     (ID1=identifier (type=typeStart | type=functionType | type=procedureType))
	 */
	protected void sequence_typeDefinition(ISerializationContext context, typeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeIdentifier returns typeIdentifier
	 *
	 * Constraint:
	 *     (
	 *         identifier=identifier | 
	 *         type='Char' | 
	 *         type='Boolean' | 
	 *         type='Integer' | 
	 *         type='Real' | 
	 *         type='String'
	 *     )
	 */
	protected void sequence_typeIdentifier(ISerializationContext context, typeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeStart returns typeStart
	 *
	 * Constraint:
	 *     (typeStart=simpleType | typeStart=structuredType | typeStart=pointerType)
	 */
	protected void sequence_typeStart(ISerializationContext context, typeStart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns unlabelledStatement
	 *
	 * Constraint:
	 *     (simpleStatement=simpleStatement | structuredStatement=structuredStatement)
	 */
	protected void sequence_unlabelledStatement(ISerializationContext context, unlabelledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unpackedStructuredType returns unpackedStructuredType
	 *
	 * Constraint:
	 *     unpackedStructuredType=recordType
	 */
	protected void sequence_unpackedStructuredType(ISerializationContext context, unpackedStructuredType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UNPACKED_STRUCTURED_TYPE__UNPACKED_STRUCTURED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UNPACKED_STRUCTURED_TYPE__UNPACKED_STRUCTURED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnpackedStructuredTypeAccess().getUnpackedStructuredTypeRecordTypeParserRuleCall_0(), semanticObject.getUnpackedStructuredType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unsignedConstant returns unsignedConstant
	 *
	 * Constraint:
	 *     (unsignedNumber=unsignedNumber | constantChr=constantChr | StringStart=StringStart | nil='nil')
	 */
	protected void sequence_unsignedConstant(ISerializationContext context, unsignedConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unsignedInteger returns unsignedInteger
	 *
	 * Constraint:
	 *     unsignedInteger=NUM_INT
	 */
	protected void sequence_unsignedInteger(ISerializationContext context, unsignedInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UNSIGNED_INTEGER__UNSIGNED_INTEGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UNSIGNED_INTEGER__UNSIGNED_INTEGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnsignedIntegerAccess().getUnsignedIntegerNUM_INTTerminalRuleCall_0(), semanticObject.getUnsignedInteger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unsignedNumber returns unsignedNumber
	 *
	 * Constraint:
	 *     (unsignedInteger=unsignedInteger | unsignedReal=unsignedReal)
	 */
	protected void sequence_unsignedNumber(ISerializationContext context, unsignedNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unsignedReal returns unsignedReal
	 *
	 * Constraint:
	 *     unsignedReal=NUM_REAL
	 */
	protected void sequence_unsignedReal(ISerializationContext context, unsignedReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.UNSIGNED_REAL__UNSIGNED_REAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.UNSIGNED_REAL__UNSIGNED_REAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnsignedRealAccess().getUnsignedRealNUM_REALTerminalRuleCall_0(), semanticObject.getUnsignedReal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     usesUnitsPart returns usesUnitsPart
	 *
	 * Constraint:
	 *     identifierList=identifierList
	 */
	protected void sequence_usesUnitsPart(ISerializationContext context, usesUnitsPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.USES_UNITS_PART__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.USES_UNITS_PART__IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUsesUnitsPartAccess().getIdentifierListIdentifierListParserRuleCall_1_0(), semanticObject.getIdentifierList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclarationPart returns variableDeclarationPart
	 *
	 * Constraint:
	 *     (variableDeclaration1=variableDeclaration (semiTerminal+=';' variableDeclaration2+=variableDeclaration)*)
	 */
	protected void sequence_variableDeclarationPart(ISerializationContext context, variableDeclarationPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclaration returns variableDeclaration
	 *
	 * Constraint:
	 *     (identifierList=identifierList typeStart=typeStart)
	 */
	protected void sequence_variableDeclaration(ISerializationContext context, variableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__IDENTIFIER_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__TYPE_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIABLE_DECLARATION__TYPE_START));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getIdentifierListIdentifierListParserRuleCall_0_0(), semanticObject.getIdentifierList());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeStartTypeStartParserRuleCall_2_0(), semanticObject.getTypeStart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variable returns variable
	 *
	 * Constraint:
	 *     (
	 *         (identifier1=identifier | identifier2=identifier) 
	 *         (identifier3+=identifier? (expression+=expression expression+=expression*)? (expression+=expression expression+=expression*)?)+
	 *     )
	 */
	protected void sequence_variable(ISerializationContext context, variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variantPart returns variantPart
	 *
	 * Constraint:
	 *     (tag=tag variant1=variant (semiTerminal+=';' variant2+=variant)*)
	 */
	protected void sequence_variantPart(ISerializationContext context, variantPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variant returns variant
	 *
	 * Constraint:
	 *     (constList=constList fieldList=fieldList)
	 */
	protected void sequence_variant(ISerializationContext context, variant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIANT__CONST_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIANT__CONST_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.VARIANT__FIELD_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.VARIANT__FIELD_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAccess().getConstListConstListParserRuleCall_0_0(), semanticObject.getConstList());
		feeder.accept(grammarAccess.getVariantAccess().getFieldListFieldListParserRuleCall_3_0(), semanticObject.getFieldList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     withStatement returns withStatement
	 *
	 * Constraint:
	 *     (recordVariableList=recordVariableList statement=statement)
	 */
	protected void sequence_withStatement(ISerializationContext context, withStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.WITH_STATEMENT__RECORD_VARIABLE_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.WITH_STATEMENT__RECORD_VARIABLE_LIST));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.WITH_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.WITH_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWithStatementAccess().getRecordVariableListRecordVariableListParserRuleCall_1_0(), semanticObject.getRecordVariableList());
		feeder.accept(grammarAccess.getWithStatementAccess().getStatementStatementParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
