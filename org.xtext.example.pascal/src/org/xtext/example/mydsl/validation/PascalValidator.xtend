/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.mydsl.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.pascal.PascalPackage
import org.xtext.example.mydsl.pascal.constantDefinition
import org.xtext.example.mydsl.pascal.identifier
import org.xtext.example.mydsl.pascal.toBegin
import org.xtext.example.mydsl.pascal.typeDefinitionPart
import org.xtext.example.mydsl.pascal.variableDeclaration
import org.xtext.example.mydsl.pascal.variableDeclarationPart
import org.xtext.example.mydsl.pascal.typeStart
import org.xtext.example.mydsl.pascal.constant
import org.eclipse.emf.common.util.EList

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	// mapa para salvar os identificadores(que representam variaveis) e seus respectivos tipos 
	public static HashMap<String, String> identificadorType = new HashMap<String, String>();
	
	//Tipos primitivos em pascal, OBS: o p no final é por conta das palavras reservadas
	public final String INTP = "integer";
	public final String REALP = "real";
	public final String STRINGP = "string";
	public final String CHARACTERP = "char";
	public final String BOOLEANP = "boolean";
	
	// Tipos Dinamicos usados para Type
	public static HashMap<String,List<String>> tiposDinamicos = new HashMap<String,List<String>>();
			 
	@Check
	def constantDefinitionPartCheck(constantDefinition constantDefinition){

		//Objeto que representa o Identificador
		var identifier = constantDefinition.ID.identifier;
		
		/** Objeto que representa o constant da gramática
		 * onde este pode ser:
		 * unsignedNumber=unsignedNumber
  		   signNumber=sign unsignedNumber=unsignedNumber
  		   identifier1=identifier
   		   signIndentifier=sign identifier2=identifier
   		   string=StringStart
   		   constantChr=constantChr //chr(5)
   		   booleanConst = bool
		 * 
		 */ 
		var constType = constantDefinition.constant;
		
		
		
		// verifica se o tipo da constante é boolean e se for salva no MAP de variáveis
		if(constType.booleanConst != null){
			identificadorType.put(identifier, BOOLEANP);
			
		// Verifica se é do tipo char , se for salva o char
		}else if(constType.constantChr !=null){
			identificadorType.put(identifier, CHARACTERP);
			
		// Verifica se o identificador
		}else if(constType.identifier1 !=null){
			// Antes é necessário saber se o indentificador já existe
			
			// 1 -busca o id no map, se existir retorna o tipo se não retorna null
			var identificadorTipo = identificadorType.get(constType.identifier1.identifier);
			
			// 2- se o id exisitir adiciona o tipo da constante ao tipo do id
			if( identificadorTipo!= null){
				identificadorType.put(identifier,identificadorTipo);
			
			// 3 se o id  não existir lança um erro
			}else{
				error("Error identifier not declared"
					,constantDefinition.constant,
					PascalPackage.Literals.CONSTANT__IDENTIFIER1
				);
			}
		}
		
		// Verifica o segundo identificador, este é o responsável pelo signIdentifier
		// Logo será necessário verificar se é um número antes de atribuir o tipo
		else if(constType.identifier2 !=null){
			// Antes é necessário saber se o indentificador já existe
			
			// 1 -busca o id no map, se existir retorna o tipo se não retorna null
			var identificadorTipo = identificadorType.get(constType.identifier2.identifier);
			
			// 2- se o id exisitir adiciona o tipo da constante ao tipo do id
			if( identificadorTipo!= null){
				// porém só se for inteiro ou real
				if(identificadorTipo.equals(INTP) || identificadorTipo.equals(REALP)){
					identificadorType.put(identifier,identificadorTipo);	
				}
				// se não for lança um erro
				else{
					error("Error identifier not Number"
							,constantDefinition.constant,
							PascalPackage.Literals.CONSTANT__SIGN_INDENTIFIER
					);
				}
			// 3 se o id  não existir lança um erro
			}else{
				error("Error identifier not declared"
					,constantDefinition.constant,
					PascalPackage.Literals.CONSTANT__IDENTIFIER2
				);
			}
		}
		
		// Verfica e adiciona para o tipo String
		else if(constType.string !=null){
			identificadorType.put(identifier, STRINGP);
		}
		// Verifica para tipo sem sinal
		else if(constType.unsignedNumber !=null){
			// variável local
			var number = constType.unsignedNumber;
			
			// se for real ..
			if(number.unsignedInteger != null){
				identificadorType.put(identifier,INTP);	
			}else{
				identificadorType.put(identifier,REALP);
			}
		}
		
		println(identificadorType);
		
	}
	
	@Check
	def typeDefinitionPartCheck(typeDefinitionPart typeDefinitionPart){
		
		// TypeDefinition
		var TypeDefinition = typeDefinitionPart.typeDefinition;
		
		// Para cada tipo definido adicionar seu identificador e atributos
		for (typeDefinition: TypeDefinition){
			// busca o id do tipo
			var identificador = typeDefinition.ID1.identifier
									
			// buscar os atributos do identificador
			
			// Salvar os atributos numa lista
			var atributos = new ArrayList<String>();
			
			// adiciona ao mapa de typos dinamicos
			tiposDinamicos.put(identificador,atributos);
			
			// só se tiver tempoooooo
			
		}
		println(tiposDinamicos);
		
	}
	
	@Check
	def variableDeclarationPart(variableDeclarationPart variableDeclarationPart){
		
		var variaveis = new ArrayList<variableDeclaration>();
		
		// Pega a primeira variável declarada
		var variaveis0 = variableDeclarationPart.variableDeclaration1;
		
		// pega a segunda ou mais  variavel declarada
		var variaveis1 = variableDeclarationPart.variableDeclaration2;
		
		// soma as duas
		variaveis.add(variaveis0);
		variaveis.addAll(variaveis1);
		
		// para cada variavel  tem que se adicionar a o mapa de identificador
		// o identifier e o tipo
		for(variavel:variaveis){
			
//			variavel.typeStart.typeStart.

			var list = new ArrayList<identifier>();
			
			// buscando a lista de  idenfiticadorres da variavel
			var identifierList = variavel.identifierList.identifier2
			// adicionando o identificador defalut
//			identifierList.add(variavel.identifierList.identifier1);
			
			list.add(variavel.identifierList.identifier1);
			list.addAll(identifierList);
			// buscando o tipo
			var tipo = getTypeStartTipo(variavel.typeStart);
			
			
			
			//para cada identificador adicionar a ao mapa com o tipo
			for (id:list){
				identificadorType.put(id.identifier,tipo)
			}
		}
		println(identificadorType);
	}
	
	@Check
	def checkToBegin(toBegin begin){
		identificadorType.clear();
		tiposDinamicos.clear();
	}
		
	/**
	 * Método para buscar o tipo do nó TypeStart
	 */
	def String getTypeStartTipo(typeStart startTipo){
		
		// se for do tipo simple ...
		if(startTipo.simple != null){
			var tipo = startTipo.simple
			
			// se for do tipo escalar
			if(tipo.scalar != null){
				
				// busca o tipo do primeiro elemento
				var tipo2 =identificadorType.get(tipo.scalar.identifierList.identifier1.identifier); 
				
				// verifica se existe
				if(tipo2 == null){
					error("Error identifier not declared"
					,tipo.scalar.identifierList.identifier1,
					PascalPackage.Literals.IDENTIFIER_LIST__IDENTIFIER1
				);}
				
				// retorna o tipo do primeiro elemento
				return tipo2
			}
			
			// se for do tipo subrange
			if(tipo.subrange != null){
				return getTypeConstant(tipo.subrange.constant1);
			}
			
			// se for do tipo identifier
			if(tipo.typeIdentifier != null){
				
				if(tipo.typeIdentifier.identifier != null){
					// busca o tipo do primeiro elemento
					var tipo2 =tiposDinamicos.get(tipo.typeIdentifier.identifier.identifier); 
					
					// verifica se existe
					if(tipo2 == null){
						error("Error identifier not declared"
						,tipo.typeIdentifier.identifier,
						PascalPackage.Literals.IDENTIFIER__IDENTIFIER
						);
						return ""
					}
					
					// retorna o tipo do primeiro elemento
					return tipo.typeIdentifier.identifier.identifier
				}
				
				if(tipo.typeIdentifier.type != null){
					return tipo.typeIdentifier.type;
				}
				
			}
			
			// se for do tipo string
			if(tipo.stringtype != null){
				return STRINGP;
			}
		}
		
		// se for do tipo structured		
		if(startTipo.structured != null){	
				return "Structured"				
		}
					
	}
	
	/**
	 * Funcao que retorna o tipo de uma constante ou um erro
	 */	
	def getTypeConstant(constant constant) {
		if(constant.booleanConst != null){
			return BOOLEANP;
			
		// Verifica se é do tipo char , se for salva o char
		}else if(constant.constantChr !=null){
			return CHARACTERP;
			
		// Verifica se o identificador
		}else if(constant.identifier1 !=null){
			// Antes é necessário saber se o indentificador já existe
			
			// 1 -busca o id no map, se existir retorna o tipo se não retorna null
			var identificadorTipo = identificadorType.get(constant.identifier1.identifier);
			
			// 2- se o id exisitir retorna o tipo da constante 
			if( identificadorTipo!= null){
				return identificadorTipo;
			
			// 3 se o id  não existir lança um erro
			}else{
				error("Error identifier not declared"
					,constant,
					PascalPackage.Literals.CONSTANT__IDENTIFIER1
				);
			}
		}
		
		// Verifica o segundo identificador, este é o responsável pelo signIdentifier
		// Logo será necessário verificar se é um número antes de atribuir o tipo
		else if(constant.identifier2 !=null){
			// Antes é necessário saber se o indentificador já existe
			
			// 1 -busca o id no map, se existir retorna o tipo se não retorna null
			var identificadorTipo = identificadorType.get(constant.identifier2.identifier);
			
			// 2- se o id exisitir adiciona o tipo da constante ao tipo do id
			if( identificadorTipo!= null){
				// porém só se for inteiro ou real
				if(identificadorTipo.equals(INTP) || identificadorTipo.equals(REALP)){
					return identificadorTipo;	
				}
				// se não for lança um erro
				else{
					error("Error identifier not Number"
							,constant,
							PascalPackage.Literals.CONSTANT__SIGN_INDENTIFIER
					);
				}
			// 3 se o id  não existir lança um erro
			}else{
				error("Error identifier not declared"
					,constant,
					PascalPackage.Literals.CONSTANT__IDENTIFIER2
				);
			}
		}
		
		// Verfica e adiciona para o tipo String
		else if(constant.string !=null){
			return STRINGP;
		}
		// Verifica para tipo sem sinal
		else if(constant.unsignedNumber !=null){
			// variável local
			var number = constant.unsignedNumber;
			
			// se for real ..
			if(number.unsignedInteger != null){
				return INTP;	
			}else{
				return REALP;
			}
		}			
	}
	
			
}
