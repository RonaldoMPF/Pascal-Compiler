grammar org.xtext.example.mydsl.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/example/mydsl/Pascal"

toBegin:
	elements += programStart
;

programStart
   : (programHeading=programHeading (interface=INTERFACE)? block=block dotTerminal=DOT)?
   ;

programHeading
   : program=PROGRAM ID=identifier (lParen=LPAREN identifierList=identifierList rparen=RPAREN)? semiTerminal=SEMI
   | {programHeading} unit=UNIT ID=identifier semiTerminal=SEMI
   ;

identifier
   : ID=IDENT
   ;

block
   : (labelDeclarationPart=labelDeclarationPart | constantDefinitionPart=constantDefinitionPart | typeDefinitionPart=typeDefinitionPart 
   	| variableDeclarationPart=variableDeclarationPart 
   	| procedureAndFunctionDeclarationPart=procedureAndFunctionDeclarationPart | usesUnitsPart=usesUnitsPart | ImplemeTerminal=IMPLEMENTATION
   )* compoundStatement=compoundStatement
   ;

usesUnitsPart
   : usesTerminal=USES identifierList=identifierList semiTerminal=SEMI
   ;

labelDeclarationPart
   : labelTerminal=LABEL labelStart1=labelStart (commaTerminal=COMMA labelStart2=labelStart)* semiTerminal=SEMI
   ;

labelStart
   : unsignedInteger=unsignedInteger
   ;

constantDefinitionPart
   : constTerminal=CONST (constantDefinition=constantDefinition semiTerminal=SEMI) +
   ;

constantDefinition
   : ID=identifier equalTerminal=EQUAL constant=constant
   ;

constantChr
   : chRTerminal=CHR lParen=LPAREN unsignedInteger=unsignedInteger rParen=RPAREN
   ;

constant
   : unsignedNumber=unsignedNumber
   | sign1=sign unsignedNumber=unsignedNumber
   | ID1=identifier
   | sign2=sign ID2=identifier
   | string=StringStart
   | constantChr=constantChr
   ;

unsignedNumber
   : unsignedInteger=unsignedInteger
   | unsignedReal=unsignedReal
   ;

unsignedInteger
   : unsignedInteger=NUM_INT
   ;

unsignedReal
   : unsignedReal=NUM_REAL
   ;

sign
   : sign= (PLUS | MINUS)
   ;

bool
   : bool= ( TRUE | FALSE)
   ;

StringStart
   : StringStart=STRING_LITERAL
   ;

typeDefinitionPart
   : typeTerminal=TYPE (typeDefinition=typeDefinition semiTerminal=SEMI) +
   ;

typeDefinition
   : ID1=identifier equalTerminal=EQUAL type = (typeStart | functionType | procedureType)
   ;

functionType
   : functionTerminal=FUNCTION (formalParameterList=formalParameterList)? colonTerminal=COLON resultType=resultType
   ;

procedureType
   : procedureTerminal=PROCEDURE (formalParameterList=formalParameterList)?
   ;

typeStart
   : typeStart = (simpleType | structuredType| pointerType)
   ;

simpleType
   : simpleType= (scalarType
   | subrangeType
   | typeIdentifier
   | stringtype)
   ;

scalarType
   : lParen=LPAREN identifierList=identifierList rParen=RPAREN
   ;

subrangeType
   : constant1=constant dotTerminal=DOTDOT constan2=constant
   ;

typeIdentifier
   : ID=identifier | type=(CHAR | BOOLEAN | INTEGER | REAL | STRING)
   ;

structuredType
   : packedTerminal=PACKED unpackedStructuredType1=unpackedStructuredType
   | unpackedStructuredType2=unpackedStructuredType
   ;

unpackedStructuredType
   : unpackedStructuredType=recordType
   ;

stringtype
   : stringTerminal=STRING lBrack=LBRACK (ID=identifier | unsignedNumber=unsignedNumber) rBrack=RBRACK
   ;

recordType
   : RECORD (fieldList=fieldList)? END
   ;

fieldList
   : fixedPart=fixedPart (SEMI variantPart1=variantPart)?
   | variantPart2=variantPart
   ;

fixedPart
   : recordSection (SEMI recordSection=recordSection)*
   ;

recordSection
   : identifierList=identifierList COLON typeStart=typeStart
   ;

variantPart
   : CASE tag=tag OF variant=variant (SEMI variant=variant)*
   ;

tag
   : ID=identifier COLON typeIdentifier1=typeIdentifier
   | typeIdentifier2=typeIdentifier
   ;

variant
   : constList=constList COLON LPAREN fieldList=fieldList RPAREN
   ;

pointerType
   : POINTER typeIdentifier=typeIdentifier
   ;

variableDeclarationPart
   : VAR variableDeclaration1=variableDeclaration (SEMI variableDeclaration2=variableDeclaration)* SEMI
   ;

variableDeclaration
   : identifierList=identifierList COLON typeStart=typeStart
   ;

procedureAndFunctionDeclarationPart
   : procedureOrFunctionDeclaration=procedureOrFunctionDeclaration SEMI
   ;

procedureOrFunctionDeclaration
   : procedureDeclaration=procedureDeclaration
   | functionDeclaration=functionDeclaration
   ;

procedureDeclaration
   : procedureTerminal=PROCEDURE identifier=identifier (formalParameterList=formalParameterList)? SEMI block=block
   ;

formalParameterList
   : LPAREN formalParameterSection1=formalParameterSection (SEMI formalParameterSection2=formalParameterSection)* RPAREN
   ;

formalParameterSection
   : parameterGroup=parameterGroup
   | varTerminal=VAR parameterGroup=parameterGroup
   | functionTerminal=FUNCTION parameterGroup=parameterGroup
   | procedureTerminal=PROCEDURE parameterGroup=parameterGroup
   ;

parameterGroup
   : identifierList=identifierList COLON typeIdentifier=typeIdentifier
   ;

identifierList
   : identifier=identifier (COMMA identifier=identifier)*
   ;

constList
   : constant=constant (COMMA constant=constant)*
   ;

functionDeclaration
   : functionTerminal=FUNCTION identifier=identifier (formalParameterList=formalParameterList)? COLON resultType=resultType SEMI block=block
   ;

resultType
   : typeIdentifier=typeIdentifier
   ;

statement
   : labelStart=labelStart COLON unlabelledStatement=unlabelledStatement
   | unlabelledStatement=unlabelledStatement
   ;

unlabelledStatement
   : {unlabelledStatement} simpleStatement=simpleStatement
   | structuredStatement=structuredStatement
   ;

simpleStatement
   : assignmentStatement=assignmentStatement
   | procedureStatement=procedureStatement
   | gotoStatement=gotoStatement
   | emptyStatement=emptyStatement
   ;

assignmentStatement
   : variable=variable ASSIGN expression=expression
   ;

variable
   : (AT identifier1=identifier | identifier2=identifier) (LBRACK expression=expression (COMMA expression=expression)* RBRACK | LBRACK2 expression=expression (COMMA expression=expression)* RBRACK2 | DOT identifier=identifier | POINTER)*
   ;

expression
   : simpleExpression=simpleExpression (relationaloperator expression=expression)?
   ;

relationaloperator
   : EQUAL
   | NOT_EQUAL
   | LT
   | LE
   | GE
   | GT
   | IN
   ;

simpleExpression
   : term=term (additiveoperator simpleExpression=simpleExpression)?
   ;

additiveoperator
   : PLUS
   | MINUS
   | OR
   ;

term
   : signedFactor=signedFactor (multiplicativeoperator term=term)?
   ;

multiplicativeoperator
   : STAR
   | SLASH
   | DIV
   | MOD
   | AND
   ;

signedFactor
   : (PLUS | MINUS)? factor=factor
   ;

factor
   : variable=variable
   | LPAREN expression=expression RPAREN
   | functionDesignator=functionDesignator
   | unsignedConstant=unsignedConstant
   | setStart=setStart
   | NOT factor=factor
   | bool=bool
   ;

unsignedConstant
   : unsignedNumber=unsignedNumber
   | constantChr=constantChr
   | StringStart=StringStart
   | NIL
   ;

functionDesignator
   : identifier=identifier LPAREN parameterList=parameterList RPAREN
   ;

parameterList
   : actualParameter1=actualParameter (COMMA actualParameter2=actualParameter)*
   ;

setStart
   : LBRACK elementList=elementList RBRACK
   | LBRACK2 elementList=elementList RBRACK2
   ;

elementList
   : element1=element (COMMA element2=element)*
   ;

element
   : expression1=expression (DOTDOT expression2=expression)?
   ;

procedureStatement
   : identifier=identifier (LPAREN parameterList=parameterList RPAREN)?
   ;

actualParameter
   : expression=expression
   ;

gotoStatement
   : GOTO labelStart=labelStart
   ;

emptyStatement
   :" "
   ;

empty
   :
   /* empty */
   " "
   ;

structuredStatement
   : compoundStatement=compoundStatement
   | repetetiveStatement=repetetiveStatement
   | withStatement=withStatement
   ;

compoundStatement
   : BEGIN statements=statements END
   ;

statements
   : statement1=statement (SEMI statement2=statement)*
   ;

repetetiveStatement
   : repeatStatement
   ;

repeatStatement
   : repeatTerminal=REPEAT statement=statements UNTIL expression
   ;

withStatement
   : withTerminal=WITH recordVariableList=recordVariableList do=DO statement=statement
   ;

recordVariableList
   : variable1=variable (COMMA variable2=variable)*
   ;


fragment A
   : ('a' | 'A')
   ;


fragment B
   : ('b' | 'B')
   ;


fragment C
   : ('c' | 'C')
   ;


fragment D
   : ('d' | 'D')
   ;


fragment E
   : ('e' | 'E')
   ;


fragment F
   : ('f' | 'F')
   ;


fragment G
   : ('g' | 'G')
   ;


fragment H
   : ('h' | 'H')
   ;


fragment I
   : ('i' | 'I')
   ;


fragment J
   : ('j' | 'J')
   ;


fragment K
   : ('k' | 'K')
   ;


fragment L
   : ('l' | 'L')
   ;


fragment M
   : ('m' | 'M')
   ;


fragment N
   : ('n' | 'N')
   ;


fragment O
   : ('o' | 'O')
   ;


fragment P
   : ('p' | 'P')
   ;


fragment Q
   : ('q' | 'Q')
   ;


fragment R
   : ('r' | 'R')
   ;


fragment S
   : ('s' | 'S')
   ;


fragment T
   : ('t' | 'T')
   ;


fragment U
   : ('u' | 'U')
   ;


fragment V
   : ('v' | 'V')
   ;


fragment W
   : ('w' | 'W')
   ;


fragment X
   : ('x' | 'X')
   ;


fragment Y
   : ('y' | 'Y')
   ;


fragment Z
   : ('z' | 'Z')
   ;


terminal AND
   : "and"
   ;
   

terminal BEGIN
   : "begin"
   ;


terminal BOOLEAN
   : "Boolean"
   ;


terminal CASE
   : "case"
   ;


terminal CHAR
   : "Char"
   ;


terminal CHR
   : "chr"
   ;


terminal CONST
   : "const"
   ;


terminal DIV
   : "div"
   ;


terminal DO
   : "do"
   ;


terminal END
   : "end"
   ;


terminal FUNCTION
   : "function"
   ;


terminal GOTO
   : "goto"
   ;


terminal IN
   : "in"
   ;


terminal INTEGER
   : "Integer"
   ;


terminal LABEL
   : "label"
   ;


terminal MOD
   : "mod"
   ;


terminal NIL
   : "nil"
   ;


terminal NOT
   : "not"
   ;


terminal OF
   : "of"
   ;


terminal OR
   : "or"
   ;


terminal PACKED
   : "packed"
   ;


terminal PROCEDURE
   : "procedure"
   ;


terminal PROGRAM
   : "program"
   ;


terminal REAL
   : "real"
   ;


terminal RECORD
   : "record"
   ;


terminal REPEAT
   : "repeat"
   ;


terminal TYPE
   : "type"
   ;


terminal UNTIL
   : "until"
   ;


terminal VAR
   : "Var"
   ;


terminal WITH
   : "with"
   ;


terminal PLUS
   : '+'
   ;


terminal MINUS
   : '-'
   ;


terminal STAR
   : '*'
   ;


terminal SLASH
   : '/'
   ;


terminal ASSIGN
   : ':='
   ;


terminal COMMA
   : ','
   ;


terminal SEMI
   : ';'
   ;


terminal COLON
   : ':'
   ;


terminal EQUAL
   : '='
   ;


terminal NOT_EQUAL
   : '<>'
   ;


terminal LT
   : '<'
   ;


terminal LE
   : '<='
   ;


terminal GE
   : '>='
   ;


terminal GT
   : '>'
   ;


terminal LPAREN
   : '('
   ;


terminal RPAREN
   : ')'
   ;


terminal LBRACK
   : '['
   ;


terminal LBRACK2
   : '(.'
   ;


terminal RBRACK
   : ']'
   ;


terminal RBRACK2
   : '.)'
   ;


terminal POINTER
   : '^'
   ;


terminal AT
   : '@'
   ;


terminal DOT
   : '.'
   ;


terminal DOTDOT
   : '..'
   ;


terminal LCURLY
   : '{'
   ;


terminal RCURLY
   : '}'
   ;


terminal UNIT
   : "unit"
   ;


terminal INTERFACE
   : "interface"
   ;


terminal USES
   : "uses"
   ;


terminal STRING_DEF
   : "String"
   ;


terminal IMPLEMENTATION
   : "implementation"
   ;


terminal TRUE
   : "true"
   ;


terminal FALSE
   : "false"
   ;



terminal COMMENT_1
   : '(*' -> '*)' 
   ;


terminal COMMENT_2
   : '{' -> '}'  
   ;


terminal IDENT
   : ('a' .. 'z' | 'A' .. 'Z') ('a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_')*
   ;


terminal STRING_LITERAL
   : '\'' //('\'\'' | ('\''))* '\''   	
   ;


terminal NUM_INT
   : INT
   ;


terminal NUM_REAL
   : //('0' .. '9') + (('.' ('0' .. '9') + (EXPONENT)?)? | EXPONENT)
   		(NUM_INT) + (('.' NUM_INT + (EXPONENT)?)? | EXPONENT)
   ;


terminal fragment EXPONENT
   : ('e') ('+' | '-')? ('0' .. '9') +
   ;
